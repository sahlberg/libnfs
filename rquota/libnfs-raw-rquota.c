/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "libnfs-zdr.h"
#include "libnfs-raw-rquota.h"

bool_t
zdr_rquotastat (ZDR *zdrs, rquotastat *objp)
{
	if (!zdr_enum (zdrs, (enum_t *) objp))
		return FALSE;
	return TRUE;
}

bool_t
zdr_exportpath (ZDR *zdrs, exportpath *objp)
{
	if (!zdr_string (zdrs, objp, RQUOTAPATHLEN))
		return FALSE;
	return TRUE;
}

bool_t
zdr_GETQUOTA1args (ZDR *zdrs, GETQUOTA1args *objp)
{
	if (!zdr_exportpath (zdrs, &objp->export))
		return FALSE;
	if (!zdr_int (zdrs, &objp->uid))
		return FALSE;
	return TRUE;
}

bool_t
zdr_quotatype (ZDR *zdrs, quotatype *objp)
{
	if (!zdr_enum (zdrs, (enum_t *) objp))
		return FALSE;
	return TRUE;
}

bool_t
zdr_GETQUOTA2args (ZDR *zdrs, GETQUOTA2args *objp)
{
	if (!zdr_exportpath (zdrs, &objp->export))
		return FALSE;
	if (!zdr_quotatype (zdrs, &objp->type))
		return FALSE;
	if (!zdr_int (zdrs, &objp->uid))
		return FALSE;
	return TRUE;
}

bool_t
zdr_GETQUOTA1res_ok (ZDR *zdrs, GETQUOTA1res_ok *objp)
{
	register int32_t *buf;
	buf = NULL;

	if (zdrs->x_op == ZDR_ENCODE) {
		buf = ZDR_INLINE (zdrs, 10 * BYTES_PER_ZDR_UNIT);
		if (buf == NULL) {
			if (!zdr_int (zdrs, &objp->bsize))
				return FALSE;
			if (!zdr_int (zdrs, &objp->active))
				return FALSE;
			if (!zdr_int (zdrs, &objp->bhardlimit))
				return FALSE;
			if (!zdr_int (zdrs, &objp->bsoftlimit))
				return FALSE;
			if (!zdr_int (zdrs, &objp->curblocks))
				return FALSE;
			if (!zdr_int (zdrs, &objp->fhardlimit))
				return FALSE;
			if (!zdr_int (zdrs, &objp->fsoftlimit))
				return FALSE;
			if (!zdr_int (zdrs, &objp->curfiles))
				return FALSE;
			if (!zdr_int (zdrs, &objp->btimeleft))
				return FALSE;
			if (!zdr_int (zdrs, &objp->ftimeleft))
				return FALSE;
		} else {
			IZDR_PUT_LONG(buf, objp->bsize);
			IZDR_PUT_LONG(buf, objp->active);
			IZDR_PUT_LONG(buf, objp->bhardlimit);
			IZDR_PUT_LONG(buf, objp->bsoftlimit);
			IZDR_PUT_LONG(buf, objp->curblocks);
			IZDR_PUT_LONG(buf, objp->fhardlimit);
			IZDR_PUT_LONG(buf, objp->fsoftlimit);
			IZDR_PUT_LONG(buf, objp->curfiles);
			IZDR_PUT_LONG(buf, objp->btimeleft);
			IZDR_PUT_LONG(buf, objp->ftimeleft);
		}
		return TRUE;
	} else if (zdrs->x_op == ZDR_DECODE) {
		buf = ZDR_INLINE (zdrs, 10 * BYTES_PER_ZDR_UNIT);
		if (buf == NULL) {
			if (!zdr_int (zdrs, &objp->bsize))
				return FALSE;
			if (!zdr_int (zdrs, &objp->active))
				return FALSE;
			if (!zdr_int (zdrs, &objp->bhardlimit))
				return FALSE;
			if (!zdr_int (zdrs, &objp->bsoftlimit))
				return FALSE;
			if (!zdr_int (zdrs, &objp->curblocks))
				return FALSE;
			if (!zdr_int (zdrs, &objp->fhardlimit))
				return FALSE;
			if (!zdr_int (zdrs, &objp->fsoftlimit))
				return FALSE;
			if (!zdr_int (zdrs, &objp->curfiles))
				return FALSE;
			if (!zdr_int (zdrs, &objp->btimeleft))
				return FALSE;
			if (!zdr_int (zdrs, &objp->ftimeleft))
				return FALSE;
		} else {
			objp->bsize = IZDR_GET_LONG(buf);
			objp->active = IZDR_GET_LONG(buf);
			objp->bhardlimit = IZDR_GET_LONG(buf);
			objp->bsoftlimit = IZDR_GET_LONG(buf);
			objp->curblocks = IZDR_GET_LONG(buf);
			objp->fhardlimit = IZDR_GET_LONG(buf);
			objp->fsoftlimit = IZDR_GET_LONG(buf);
			objp->curfiles = IZDR_GET_LONG(buf);
			objp->btimeleft = IZDR_GET_LONG(buf);
			objp->ftimeleft = IZDR_GET_LONG(buf);
		}
	return TRUE;
	}

	if (!zdr_int (zdrs, &objp->bsize))
		return FALSE;
	if (!zdr_int (zdrs, &objp->active))
		return FALSE;
	if (!zdr_int (zdrs, &objp->bhardlimit))
		return FALSE;
	if (!zdr_int (zdrs, &objp->bsoftlimit))
		return FALSE;
	if (!zdr_int (zdrs, &objp->curblocks))
		return FALSE;
	if (!zdr_int (zdrs, &objp->fhardlimit))
		return FALSE;
	if (!zdr_int (zdrs, &objp->fsoftlimit))
		return FALSE;
	if (!zdr_int (zdrs, &objp->curfiles))
		return FALSE;
	if (!zdr_int (zdrs, &objp->btimeleft))
		return FALSE;
	if (!zdr_int (zdrs, &objp->ftimeleft))
		return FALSE;
	return TRUE;
}

bool_t
zdr_GETQUOTA1res (ZDR *zdrs, GETQUOTA1res *objp)
{
	if (!zdr_rquotastat (zdrs, &objp->status))
		return FALSE;
	switch (objp->status) {
	case RQUOTA_OK:
		if (!zdr_GETQUOTA1res_ok (zdrs, &objp->GETQUOTA1res_u.quota))
			return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}
